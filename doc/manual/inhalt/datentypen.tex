Die scdc\_defs.h beinhaltet vor allem Definitionen von Datentypen.\\
In scdc\_args.h sind weitere Datentypen für den internen Gebrauch.

\subsection{scdcint\_t}\label{scdcint_t}
Bei Rückgabe von scdcint\_t mit Wert \textbf{SCDC\_SUCCESS}(=1LL) oder \textbf{SCDC\_FAILURE}(=0LL)\\
Sonst benutzt zur Übergabe von Integerwerten, dabei können bei Konfigurationen entsprechende Werte durch Defines benannt sein.
\begin{lstlisting}[label={l:scdcint_t}]
typedef long long scdcint_t;
\end{lstlisting}


\subsection{scdc\_nodeport\_t}\label{scdc_nodeport_t}
Handel für einen Nodeport. Rückgabe der Funktion \hyperref[scdc_nodeport_open]{\texttt{scdc\_nodeport\_open()}}
\begin{lstlisting}[label={l:scdc_nodeport_t}]
// in scdc.h :
typedef void *scdc_nodeport_t;
\end{lstlisting}


\subsection{scdc\_dataprov\_t}\label{scdc_dataprov_t}
Als Rückgabe bei \hyperref[scdc_dataprov_open]{\texttt{scdc\_dataprov\_open()}}. Dient als handle für Datenprovider.\\
\begin{lstlisting}[label={l:scdc_dataprov_t}]
typedef void *scdc_dataprov_t;
\end{lstlisting}


\pagebreak
\subsection{scdc\_dataprov\_hook\_t}\label{scdc_dataprov_hook_t}
Die angegeben Funktionen werden beim Datenprovider registriert. Dazu wird eine Variable von diesem Datentyp mit entsprechenden Funktionspointern der Funktion
\hyperref[scdc_dataprov_open]{scdc\_dataprov\_open} als Parameter übergeben.
\begin{minipage}{\textwidth}
\begin{lstlisting}[escapechar={~}, label={l:scdc_dataprov_hook_t}]
typedef struct _scdc_dataprov_hook_t
{
  // in scdc_defs.h :
  /// Datenstruktur nimmt Funktionen entgegen die vom Anwender zu schreiben sind
  scdc_dataprov_hook_open_f                      *open;
  scdc_dataprov_hook_close_f                     *close;
  scdc_dataprov_hook_config_f                    *config;

  scdc_dataprov_hook_dataset_open_f              *dataset_open;
  scdc_dataprov_hook_dataset_close_f             *dataset_close;

  scdc_dataprov_hook_dataset_open_read_state_f   *dataset_open_read_state;
  scdc_dataprov_hook_dataset_close_write_state_f *dataset_close_write_state;

  // Funktion die Kommandos (Berechnungen) auf Daten ausführt
  scdc_dataprov_hook_dataset_cmd_f               *dataset_cmd;

} scdc_dataprov_hook_t;

	/* dataprov_hook Funktionstypen mit FKT-Definition */
	typedef ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ scdc_dataprov_hook_config_f( void *dataprov, const char *cmd, const char *param, const char *val, ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ val_size, char **result, ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ *result_size);
	typedef void *scdc_dataprov_hook_open_f( const char *conf, va_list ap);
	typedef ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ scdc_dataprov_hook_close_f( void *dataprov);
	typedef void *scdc_dataprov_hook_dataset_open_f( void *dataprov, const char *path);
	typedef ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ scdc_dataprov_hook_dataset_close_f( void *dataprov, void *dataset);
	typedef void *scdc_dataprov_hook_dataset_open_read_state_f( void *dataprov, const char *buf, ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ buf_size);
	typedef ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ scdc_dataprov_hook_dataset_close_write_state_f( void *dataprov, void *dataset, char *buf, ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ buf_size);
	typedef ~\hyperref[scdcint_t]{\texttt{scdcint\_t}}~ scdc_dataprov_hook_dataset_cmd_f( void *dataprov, void *dataset, const char *cmd, const char *params, ~\hyperref[scdc_dataset_input_t]{\texttt{scdc\_dataset\_input\_t}}~ *input, ~\hyperref[scdc_dataset_output_t]{\texttt{scdc\_dataset\_output\_t}}~ *output);

\end{lstlisting}
\end{minipage}

Die \textbf{\texttt{scdc\_dataprov\_hook\_config\_f}} Funktion ist gedacht, um die Konfiguration über eine bestimmte URL aufzurufen und den Datenprovider so während der Laufzeit einzustellen. Beispiele Kapitel \ref{k:hookfunkbsp}.


\subsection{scdc\_dataset\_t}\label{scdc_dataset_t}
Handel auf einen Datensatz. Rückgabe der Funktion \hyperref[scdc_dataset_open]{\texttt{scdc\_dataset\_open()}}\\
\begin{minipage}{\textwidth}
\begin{lstlisting}[escapechar={°}, label={l:scdc_dataset_t}]
// src/lib/scdc/scdc.h:
	typedef struct _scdc_dataset_t *scdc_dataset_t;
    
// src/lib/scdc/scdc.cc:
	struct _scdc_dataset_t	{
	  _scdc_dataset_t()
		:nodeconn(0), dataset(0)
	  {
		buf = new char[DEFAULT_LIBSCDC_BUF_SIZE];
		buf_size = DEFAULT_LIBSCDC_BUF_SIZE;
	  }

	  ~_scdc_dataset_t()
	  {
		delete[] buf;
	  }

	  scdc_nodeconn *nodeconn;
	  scdc_dataset *dataset;
	  char *buf;
	  °\hyperref[scdcint_t]{\texttt{scdcint\_t}}° buf_size;
	};
\end{lstlisting}
\end{minipage}


\subsection{scdc\_dataset\_inout\_intern\_t}\label{scdc_dataset_inout_intern_t}
\begin{minipage}{\textwidth}
\begin{lstlisting}[label={l:scdc_dataset_inout_intern_t}]
// in dataset_inout.h
typedef struct _scdc_dataset_inout_intern_t
{
  scdcint_t alloc_size, type;
  void *buf, *data;

  scdc_dataset_inout_destroy_f *destroy;

} scdc_dataset_inout_intern_t;

// mit Funktionsbeschreibung
typedef void scdc_dataset_inout_destroy_f(scdc_dataset_inout_t *inout);
\end{lstlisting}
\end{minipage}


\pagebreak
\subsection{scdc\_dataset\_input\_t \& scdc\_dataset\_output\_t}\label{scdc_dataset_input_t}\label{scdc_dataset_output_t}\label{scdc_dataset_inout_t}
Mit dieser Struktur wird das Input-Objekt und das Output-Objekt für Datensätze beschrieben. 
Es wird benutzt um die Daten anzugeben, welche zwischen Client und Service Provider übertragen werden. \\
Funktionen dazu in dataset\_inout.h zu finden.\\
Hinweis: \texttt{\_scdc\_dataset\_inout\_intern\_t} und intern\_data bei von Hand befüllen \textbf{ignorieren}.\\
Verwendet von \hyperref[scdc_dataset_cmd]{\texttt{scdc\_dataset\_cmd()}}\\
\begin{minipage}{\textwidth}
\begin{lstlisting}[escapechar={~}, label={l:scdc_dataset_inout_t}]
// in scdc_defs.h :
typedef scdc_dataset_inout_t scdc_dataset_input_t;
typedef scdc_dataset_inout_t scdc_dataset_output_t;

typedef struct _scdc_dataset_inout_t
{
  char format[SCDC_FORMAT_MAX_SIZE];

  scdcint_t buf_size;
  void *buf;

  scdcint_t current_size, total_size;
  char total_size_given;

  scdc_dataset_inout_next_f *next;

  void *data;

  struct ~\hyperref[scdc_dataset_inout_intern_t]{\texttt{\_scdc\_dataset\_inout\_intern\_t}}~ *intern;
  void *intern_data;
  
} scdc_dataset_inout_t;
\end{lstlisting}
\end{minipage}\\
{\begin{minipage}{\textwidth}
\underline{Member}:\\[1ex]
\small
\hspace*{2em}\begin{minipage}{0.8\textwidth}
\begin{description}
\setlength{\itemsep}{-3pt}
\item[- format]: String der das Datenformat beschreibt. Wird mit übertragen und kann beliebig gesetzt werden.
\item[- buf]: Data-Buffer - Die Daten in dem Buffer werden übertragen.
\item[- buf\_size]: Größe des Data-Buffer.
\item[- current\_size]: Größe, bzw. Menge der zur Zeit verfügbaren Daten innerhalb des Data buffers.
\item[- total\_size]: Derzeitig bekannte komplette Menge der Eingabe oder Ausgabe.
\item[- total\_size\_given]: Definiert wie der gegebene Wert total\_size interpretiert wird. Vordefinierte Werte:\\
                              SCDC\_DATASET\_INOUT\_TOTAL\_SIZE\_GIVEN\_EXACT,\\
                              SCDC\_DATASET\_INOUT\_TOTAL\_SIZE\_GIVEN\_AT\_LEAST,\\ 
                              SCDC\_DATASET\_INOUT\_TOTAL\_SIZE\_GIVEN\_AT\_MOST,\\
                              SCDC\_DATASET\_INOUT\_TOTAL\_SIZE\_GIVEN\_NONE.
\item[- next]: Funktionshandel zu einer Funktion, welche den nächsten Teil der Eingabe oder weitere Ausgabedaten liefert. (Sie füllt normalerweise den Buffer mit weiteren Daten, alle Übertragungsdaten komplett sind.)
\item[- data]: Frei nutzbares Daten Feld (z.B. zum Speichern von Zustandsinformationen). Kann benutzt werden um weitere Daten zu hinterlegen, die später benötigt werden. (Speziell Zeiger auf Daten, die die Next-Funktion in den Buffer kopiert, für weitere Übertragung.)
\item[- intern]: Intern von SCDC genutztes Handel. (Nicht für Anwender gedacht, jedoch muss dieses mit der Funktion \hyperref[scdc_dataset_inout_unset]{scdc\_dataset\_output/input\_unset()} auf vordefinierte werte gesetzt werden.)
\item[-  intern\_data]: Frei nutzbares Daten Feld für internen gebrauch.  (Nicht für Anwender nutzbar.)
\end{description}
\end{minipage}
\end{minipage}}

\vspace{2ex}
\pagebreak
\textbf{Funktionsrumpf für Next-Funktion (siehe auch Abs. \ref{scdc_dataset_inout_next_f}):}
\begin{lstlisting}[escapechar={~}, label={l:td_next_fct}]
scdcint_t td_next_fct(struct _scdc_dataset_inout_t *inout)
{
	// Buffer neu Befüllen und alle anderen Werte in inout neu setzen.
	inout->buf          = ...;
	inout->buf_size     = ...;
	inout->current_size = ...;
	// Weiteres ...
	if(<keine Daten>)
		inout->next=NULL; //Wichtig!
		
	return SCDC_SUCCESS;
}
\end{lstlisting}

\begin{minipage}{\textwidth}
Beim Abrufen der Daten aus der Struktur muss die Next-Funktion solange in einer Schleife abgerufen werden bis keine Daten mehr vorhanden sind und 
der Pointer \texttt{inout->next} gleich Null gesetzt ist.
\begin{lstlisting}[escapechar={~}]
if(input->nex != NULL)
{
// Weitere Daten aus input abrufen
input->next(input);
}
else
{ ... /*Alle Daten empfangen*/ }
\end{lstlisting}
\end{minipage}


\subsection{scdc\_dataset\_inout\_next\_f}\label{scdc_dataset_inout_next_f}
Funktionsdescriptor für die next-Funktion.
\begin{lstlisting}[escapechar={°}, label={l:scdc_dataset_inout_next_f}]
// in scdc_defs.h :
typedef °\hyperref[scdcint_t]{\texttt{scdcint\_t}}° scdc_dataset_inout_next_f(struct _scdc_dataset_inout_t *inout);
\end{lstlisting}
Funktion die dazu dient weitere Daten im Buffer bereit zu stellen. Funktion muss vom Anwender geschrieben werden und in der Datenstruktur
\hyperref[scdc_dataset_input_t]{\texttt{scdc\_dataset\_input/output\_t}} unter \textit{next} hinterlegt wird.
Beim Abruf der nächste Daten wird diese Funktion wieder vom Anwender aufgerufen
Funktion der Form (BSP):
\begin{lstlisting}[escapechar={°}]
scdcint_t input_next(scdc_dataset_input_t *input)
{
	// Anpassen der variable scdc_dataset_input_t *input
	// mit neuen Werten
	set_new(input->buf)
	set_correct_values(input)
	
	return SCDC_SUCCESS;
}
\end{lstlisting}

Auslesen: Next-Funktion immer händisch aufrufen und erneut buf auslesen.
Gedacht um Daten zu übertragen die nicht mit einmal im Speicher liegen. 
Zu große Datenmenge oder on-the-fly generierte Daten sind dann so auch übertragbar.



